<!doctype html>
<html>
<head>
<title>Racko generated document</title>
<style>

html {
  height: 100%;
}

body {
  background-color: black;
  color: #ccc;
  font-size: 14px;
  line-height: 18px;
  height: 100%;
  margin: 0;
  padding: 0;
}

#container {
  min-height: 100%;
  position: relative;
}

#background {
  background: #fff;
  position: absolute;
  top: 0;
  bottom: 0;
  width: 350px;
  border-right: 1px solid #e5e5ee;
  z-index: -1;
}

ul {
  list-style: outside none none;
  padding: 0 0 5px 0;
  margin: 0;
}

li {
  white-space: nowrap;
}

div {
  display: inline-block;
box-sizing: border-box;
}

pre {
  font-size: 12px;
  line-height: 16px;
  font-family: Menlo, Monaco, Consolas, "Lucida Console", monospace;
  margin: 0;
  padding: 0;
}

.annotation {
  max-width: 350px;
  min-width: 350px;
  min-height: 5px;
  padding: 13px;
  overflow-x: hidden;
  white-space: normal;
  text-align: left;
  vertical-align: top;
  color: black;
}

.content {
  padding: 13px;
  vertical-align: top;
  border: none;
}

</style>
<script>
</script>
</head>
<body>
<div id="container">
<div id='background'></div>
<ul>
<li><div class='annotation'>
<p>
 Racko, a code documenting tool
</p>
</div><div class='content'><pre>
#lang racket/base

#|
Source files are made up of different syntaxes and keywords
Different words and segments should be colored different

Colors will be broken down into the following groups:
keyword, type, comment

Each group can have multiple coloring tags to customize
syntax and make certain syntax stand out better
ie; 'for' in C++ can have a different coloring than 'return'


|#


</pre></div></li>
<li><div class='annotation'>
<p>
 Program requires
</p>
</div><div class='content'><pre>
(require racket/cmdline)
(require racket/string)


</pre></div></li>
<li><div class='annotation'>
<p>
 Program constants
</p>
</div><div class='content'><pre>
(define PROGRAM-NAME          "racko")
(define PROGRAM-VERSION         "0.1")
(define JS-FILENAME       "script.js")
(define CSS-FILENAME      "style.css")


</pre></div></li>
<li><div class='annotation'>
<p>
 Program command line options
</p>
</div><div class='content'><pre>
(define inline-cssjs       (make-parameter     #f))
(define verbosity-mode     (make-parameter     #f))
(define output-base-folder (make-parameter "docs"))


</pre></div></li>
<li><div class='annotation'>
<p>
 parser parameters for rendering html and other things
</p>
</div><div class='content'><pre>
(define section-number       (make-parameter    0))
(define code-accum           (make-parameter   ""))
(define inside-section?      (make-parameter   #f))
(define inside-annotation?   (make-parameter   #f))


</pre></div></li>
<li><div class='annotation'>
<p>
 Structs to describe parser settings and syntax groups
</p>
</div><div class='content'><pre>
(struct psettings (sl-comment-begin ml-comment-begin ml-comment-end))
(struct syngroups (group1 group2 group3 group4))


</pre></div></li>
<li><div class='annotation'>
<p>
 a very large CSS string
</p>
</div><div class='content'><pre>
(define DOC-STYLE "
html {
  height: 100%;
}

body {
  background-color: black;
  color: #ccc;
  font-size: 14px;
  line-height: 18px;
  height: 100%;
  margin: 0;
  padding: 0;
}

#container {
  min-height: 100%;
  position: relative;
}

#background {
  background: #fff;
  position: absolute;
  top: 0;
  bottom: 0;
  width: 350px;
  border-right: 1px solid #e5e5ee;
  z-index: -1;
}

ul {
  list-style: outside none none;
  padding: 0 0 5px 0;
  margin: 0;
}

li {
  white-space: nowrap;
}

div {
  display: inline-block;
box-sizing: border-box;
}

pre {
  font-size: 12px;
  line-height: 16px;
  font-family: Menlo, Monaco, Consolas, \"Lucida Console\", monospace;
  margin: 0;
  padding: 0;
}

.annotation {
  max-width: 350px;
  min-width: 350px;
  min-height: 5px;
  padding: 13px;
  overflow-x: hidden;
  white-space: normal;
  text-align: left;
  vertical-align: top;
  color: black;
}

.content {
  padding: 13px;
  vertical-align: top;
  border: none;
}
")


</pre></div></li>
<li><div class='annotation'>
<p>
 lines to start the file with (css/js declarations included)
</p>
<p>
 if the inline-cssjs state is #t, write it to the header
</p>
<p>
 else, link it to local files and those adjacent to the docs
</p>
</div><div class='content'><pre>
(define html-header-lines
  (list "&lt;!doctype html&gt;"
    "&lt;html&gt;"
    "&lt;head&gt;"
    "&lt;title&gt;Racko generated document&lt;/title&gt;"
    "&lt;style&gt;"
    DOC-STYLE
    "&lt;/style&gt;"
    "&lt;script&gt;"
    "&lt;/script&gt;"
    "&lt;/head&gt;"

    "&lt;body&gt;"
    "&lt;div id=\"container\"&gt;"
    "&lt;div id='background'&gt;&lt;/div&gt;"
    "&lt;ul&gt;"))



</pre></div></li>
<li><div class='annotation'>
<p>
 lines after everything has been done
</p>
</div><div class='content'><pre>
(define html-footer-lines
  '("&lt;/ul&gt;"
    "&lt;/div&gt;"
    "&lt;footer&gt;Created by Racko&lt;/footer&gt;"
    "&lt;/body&gt;"
    "&lt;/html&gt;"))



</pre></div></li>
<li><div class='annotation'>
<p>
 return a path based on the target folder and filename
</p>
</div><div class='content'><pre>
(define (build-file-path filename)
  (define-values (dir fname d?) (split-path filename))
  (build-path (current-directory)
              (output-base-folder)
              (string-append (path-&gt;string fname) ".html")))



</pre></div></li>
<li><div class='annotation'>
<p>
 prefabricate some HTML into the output file
</p>
</div><div class='content'><pre>
(define (write-lines-to-file lines)
  (λ (output-port)
    (for-each (λ (l) (displayln l output-port)) lines)))

(define write-header (write-lines-to-file html-header-lines))
(define write-footer (write-lines-to-file html-footer-lines))
  


</pre></div></li>
<li><div class='annotation'>
<p>
 sanitize a line with html escapes
</p>
</div><div class='content'><pre>
(define (sanitize line)
  (regexp-replaces line '([#rx"&lt;" "\\&lt;"] [#rx"&gt;" "\\&gt;"])))

(define (remove-comment line slc)
  (string-trim (string-trim line " " #:repeat? #t) slc #:right? #f))



</pre></div></li>
<li><div class='annotation'>
<p>
 add code to the code accumulator
</p>
</div><div class='content'><pre>
(define (add-code line output)
  (unless (inside-section?)
    (inside-section? #t)
    (displayln "&lt;li&gt;&lt;div class='annotation'&gt;&lt;/div&gt;&lt;div class='content'&gt;&lt;pre&gt;" output))

  (when (inside-annotation?)
    (displayln "&lt;/div&gt;&lt;div class='content'&gt;&lt;pre&gt;" output)
    (inside-annotation? #f))
  (code-accum (string-append (code-accum) line "\n")))



</pre></div></li>
<li><div class='annotation'>
<p>
 write code to the file from the accumulator
</p>
</div><div class='content'><pre>
(define (write-code output)
  (unless (string=? "" (code-accum))
    (displayln (code-accum) output)
    (code-accum "")
    (displayln "&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;" output)
    (inside-section? #f)))


</pre></div></li>
<li><div class='annotation'>
<p>
 writing code lines goes here
</p>
</div><div class='content'><pre>
(define (write-comment-line line output)

  (write-code output) ; flush any code and close a section

  (unless (inside-section?)
    (inside-section? #t)
    (inside-annotation? #t)
    (displayln "&lt;li&gt;&lt;div class='annotation'&gt;" output))

  (displayln "&lt;p&gt;"  output)
  (displayln line   output)
  (displayln "&lt;/p&gt;" output))
    


</pre></div></li>
<li><div class='annotation'>
<p>
 parse logic should go here
</p>
</div><div class='content'><pre>
(define (parse-line line output-port slc)
  (define sanitized-line (sanitize line))
  (define trimmed-line (string-trim sanitized-line " " #:repeat? #t #:right? #f))
  (if (string-startswith? trimmed-line slc)
      (write-comment-line (string-trim trimmed-line slc #:repeat? #t #:right? #f) output-port)
      (add-code sanitized-line output-port)))



</pre></div></li>
<li><div class='annotation'>
<p>
 determines whether string A starts with string B
</p>
<p>
 if B is longer than A, return false
</p>
</div><div class='content'><pre>
(define (string-startswith? string-a string-b)
  (if (&lt; (string-length string-a) (string-length string-b))
      #f
      (string=? string-b (substring string-a 0 (string-length string-b)))))
  


</pre></div></li>
<li><div class='annotation'>
<p>
 build a parser using a settings struct(?)
</p>
</div><div class='content'><pre>
(define (parser parse-settings)
  (λ (filename)
    (define fr (file-reader (string-&gt;path filename)))
    (define op (open-output-file (build-file-path filename) #:exists 'replace))

    (write-header op)

    (define (parse-all-lines generator)
      (define line (generator))
      (unless (eof-object? line)
        (parse-line line op (psettings-sl-comment-begin parse-settings))
        (parse-all-lines generator)))
    
    (parse-all-lines fr)

    (write-code op)
    (write-footer op)
              
    (displayln "I'm parsing a file!")))



</pre></div></li>
<li><div class='annotation'>
<p>
 all languages supported (start with racket and c++)
</p>
</div><div class='content'><pre>
(define languages
  (make-hash
   (list
    (list "rkt" (list "racket" (parser (psettings ";"  #rx"#|"   #rx"|#"))))
    (list "c"   (list "c"      (parser (psettings "//" #rx"/\\*" #rx"\\*/"))))
    (list "cpp" (list "c++"    (parser (psettings "//" #rx"/\\*" #rx"\\*/"))))
    )))


</pre></div></li>
<li><div class='annotation'>
<p>
 print all languages supported for the program
</p>
</div><div class='content'><pre>
(define (print-supported-extensions)
  (displayln "List of Languages supported")
  (displayln "---------------------------")
  (for-each displayln (hash-&gt;list languages)))



</pre></div></li>
<li><div class='annotation'>
<p>
 return a filename's extension without the period
</p>
</div><div class='content'><pre>
(define (get-extension filename)
  (car (reverse (string-split filename "."))))

(define (create-docs filename)
  (define extension (get-extension filename))
  
  (unless (hash-has-key? languages (get-extension filename))
    (displayln "Not supported!")
    (exit 0))

  (define selected-parser (car (hash-ref languages extension)))
  (define lang (car selected-parser))
  (define lang-parser (car (cdr selected-parser)))

  (when (verbosity-mode)
    (displayln (format "File given: ~a" filename))
    (displayln (format "Extension: ~a" extension))
    (displayln (format "Output folder: ~a" (output-base-folder)))
    (displayln (format "Target file: ~a" (path-&gt;string (build-file-path filename))))
    (displayln (format "Language: ~a" lang))
    (displayln (format "Parser: ~a" lang-parser))
    )

  (lang-parser filename)

  (displayln "Done"))



</pre></div></li>
<li><div class='annotation'>
<p>
 A file reading generator that reads a file line-by-line
</p>
<p>
 Returns the next line in the file each time it is called
</p>
</div><div class='content'><pre>
(define (file-reader filename)
  (define p (open-input-file filename))
  (λ ()
    (read-line p)))

(command-line
 #:program PROGRAM-NAME
 #:once-each
 [("-v" "--verbose") "Enable more text at runtime" (verbosity-mode #t)]
 [("-o" "--output")
  output-dir
  "Destination folder to save docs to" (output-base-folder output-dir)]

 [("--print-languages") "Print supported languages" (print-supported-extensions) (exit 0)]

 #:args (filename)
 (create-docs filename)
 )

</pre></div></li>
</ul>
</div>
<footer>Created by Racko</footer>
</body>
</html>
